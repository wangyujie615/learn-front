![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/43189118/1743513475827-59190fa6-1d61-48bf-a3de-90f25f27531d.jpeg)

# 网络结构层次
## 1.OSI七层模型
![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743484581461-04147cc2-b3fc-4f8e-8731-8f4ad10a81eb.png)

OSI七层网络模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

### (1) 应用层
**<font style="color:#ECAA04;">作用</font>**：`OSI`参考模型中最靠近用户的一层，是**<font style="color:#FBDE28;">为计算机用户提供应用接口，也为用户直接提供各种网络服务。</font>**

常见应用层的网络服务协议有：`HTTP`，`HTTPS`，`FTP`，`POP3`、`SMTP`等。

+ <font style="color:#000000;">在客户端与服务器中经常会有数据的请求，这个时候就是会用到</font>`<font style="color:#000000;">http(hyper text transfer protocol)(超文本传输协议)</font>`<font style="color:#000000;">或者</font>`<font style="color:#000000;">https</font>`<font style="color:#000000;">在后端设计数据接口时，我们常常使用到这个协议。</font>
+ `<font style="color:#000000;">FTP</font>`<font style="color:#000000;">是文件传输协议，比如</font>`<font style="color:#000000;">百度网盘``迅雷</font>`<font style="color:#000000;">应该是基于此协议的。</font>
+ `<font style="color:#000000;">SMTP</font>`<font style="color:#000000;">是</font>`<font style="color:#000000;">simple mail transfer protocol（简单邮件传输协议）</font>`<font style="color:#000000;">。在一个项目中，在</font>**<font style="color:#000000;">用户邮箱验证码登录</font>**<font style="color:#000000;">的功能时，使用到了这个协议。</font>

### (2) 表示层
作用：提供各种**<font style="color:#ECAA04;">用于应用层数据的编码和转换功能</font>**,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。数据压缩和加密也是表示层可提供的转换功能之一。



在项目开发中，为了方便数据传输，可以使用`base64`对数据进行编解码。如果按功能来划分，`base64`应该是工作在表示层。

### (3) 会话层
作用：会话层就是**<font style="color:#ECAA04;">负责建立、管理和终止表示层实体之间的通信会话</font>**。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

### (4) 传输层
传输层建立了主机端到端的链接，传输层的作用是**<font style="color:#ECAA04;">为上层协议提供端到端的可靠和透明的数据传输服务</font>**，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，`TCP` `UDP`就是在这一层。端口号既是这里的“端”

### (5) 网络层
本层通过`IP`寻址来建立两个节点之间的连接，为源端的运输层送来的分组，**<font style="color:#ECAA04;">选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层</font>**。就是通常说的`IP`层。这一层就是我们经常说的`IP`协议层。`IP`协议是`Internet`的基础。我们可以这样理解，**<font style="color:#ECAA04;">网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式</font>**。

### (6) 数据链路层
将比特组合成字节,再将字节组合成**<font style="color:#ECAA04;">帧</font>**,使用链路层地址 (以太网**<font style="color:#ECAA04;">使用MAC地址)</font>**来访问介质,并进行差错检测。

网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，**<font style="color:#ECAA04;">网络层是规划了数据包的传输路线，而数据链路层就是传输路线</font>**。不过，在数据链路层上还增加了**<font style="color:#ECAA04;">差错控制</font>**的功能。

### (7) 物理层
实际最终信号的传输是通过物理层实现的。通过物理介质**<font style="color:#ECAA04;">传输比特流</font>**。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

## 2.TCP/IP四层模型
![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743485503314-9f3c89f2-58e9-45ab-a0db-7c07e6f0dede.png)

## 3.数据传输过程
![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743486203424-e2a4abca-dc2d-427e-ab19-f98479455974.png)

![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743486649979-dfb8f977-4ca0-43af-ae91-37ad9bd31fda.png)

+ <font style="color:#000000;">物理层：</font><font style="color:#000000;">在物理层所</font>**<font style="color:#A58F04;">传的数据单位是比特</font>**<font style="color:#000000;">，也就是二进制数据。</font>
+ <font style="color:#000000;">数据链路层：数据链路层将网络层传递下来的IP数据或者物理层上传的数据报</font>**<font style="color:#A58F04;">组装成帧</font>**<font style="color:#000000;">，在两个相邻的节点</font>**<font style="color:#A58F04;">通过节点的MAC地址进行帧的传送</font>**<font style="color:#000000;">。其中帧包括数据和必要的</font>**<font style="color:#A58F04;">控制信息</font>**<font style="color:#000000;">，以便让接收端能够知道一个帧从那个比特开始和到那个比特结束，这样以来数据链路层就可以通过这个控制信息提取出数据部分上交给上一层网络层或者传递给物理层。</font>**<font style="color:#A58F04;">控制信息还可以让接收端在接收到一个数据帧的时候对其进行检测，如果检测的结果显示接收的数据帧不完整或者有错误，将会丢弃这个数据帧</font>**<font style="color:#000000;">。</font>
+ <font style="color:#000000;">网络层：在发送数据的时候，网络层将运输层的</font>**<font style="color:#A58F04;">数据报文封装成包进行传送</font>**<font style="color:#000000;">，网络层的协议是无连接的IP协议。</font>
+ <font style="color:#000000;">传输层：传输层主要使用两种传输协议：</font>`<font style="color:#000000;background-color:rgb(249, 242, 244);">TCP</font>`<font style="color:#000000;">与</font>`<font style="color:#000000;background-color:rgb(249, 242, 244);">UDP</font>`<font style="color:#000000;">。其中TCP是面向连接的，可靠的数据传输服务，数据不会出现丢失的情况。UDP是面向无连接，但是数据传输可能会有丢包的情况出现。</font>
+ <font style="color:#000000;">应用层：应用层是体系结构中最高层，应用层协议定义的是应用进程间通信和交互的规则。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743490307060-83ebe534-ef6b-4e1b-976d-526afa4bee8c.png)

![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743490320720-3a73aa60-d6f3-4758-96cc-aeab6dbbcbfc.png)

![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743490335045-e4aa042c-49a2-42ec-a393-23347193b715.png)

# TCP/UDP
## 1.TCP/UDP概念和特点
### （1）TCP 
TCP：是一种**<font style="color:#ECAA04;">面向连接的、可靠的、基于字节流</font>**的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。



特点：

**1）面向连接**

**<font style="color:#ECAA04;">面向连接，是指发送数据之前必须在两端建立连接</font>**。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

**2）仅支持单播传输**

每条TCP传输连接只能有两个端点，**<font style="color:#ECAA04;">只能进行点对点的数据传输</font>**，不支持多播和广播传输方式。

**3）面向字节流**

**<font style="color:#ECAA04;">是在不保留报文边界的情况下以字节流方式进行传输</font>**。

**4）可靠传输**

对于可靠传输，**<font style="color:#ECAA04;">判断丢包、误码靠的是TCP的段编号以及确认号</font>**。TCP为了保证报文传输的可靠，**<font style="color:#ECAA04;">就给每个包一个序号</font>**，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

**5）提供拥塞控制**

当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。

**6）提供全双工通信**

TCP允许通信双方的应用程序在任何时候都能发送数据，**<font style="color:#ECAA04;">因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。</font>**当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）

### （2）UDP
UDP：是**用户数据报协议**，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和**<font style="color:#ECAA04;">不能对数据包进行排序</font>**的缺点，也就是说，当**<font style="color:#ECAA04;">报文发送之后，是无法得知其是否安全完整到达的</font>**。



特点：

**1）面向无连接**

**<font style="color:#ECAA04;">发送数据前不需要建立连接，想发数据就可以开始发送了</font>**。并且也只是数据报文的搬运工，**<font style="color:#ECAA04;">不会对数据报文进行任何拆分和拼接操作</font>**。



具体来说就是：

+ 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
+ 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

**2）有单播，多播，广播的功能**

UDP 不止支持一对一的传输方式，**<font style="color:#ECAA04;">同样支持一对多，多对多，多对一的方式</font>**，也就是说 UDP 提供了**<font style="color:#ECAA04;">单播，多播，广播</font>**的功能。

**3）面向报文**

发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。**<font style="color:#ECAA04;">UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</font>**。因此，应用程序必须选择合适大小的报文

**4）不可靠性(无连接、无拥塞控制)**

首先**<font style="color:#ECAA04;">不可靠性体现在无连接上</font>**，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，**<font style="color:#ECAA04;">发送数据也不会关心对方是否已经正确接收到数据了。</font>**



再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

**5）头部开销小，传输数据报文时是很高效的。**

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023358917-72134998-53bd-4d9c-b71f-7a762dff31a9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

UDP 头部包含了以下几个数据：

+ 两个十六位的端口号，分别为源端口（可选字段）和目标端口
+ 整个数据报文的长度
+ 整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误



因此 UDP 的头部开销小，**<font style="color:#ECAA04;">只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</font>**

## <font style="color:#000000;">2.TCP/UDP的区</font>
|  | UDP | TCP |
| :---: | :---: | :---: |
| 是否连接 | 无连接 | 面向连接 |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信 |
| 传输方式 | 面向报文 | 面向字节流 |
| 首部开销 | 首部开销小，仅8字节 | 首部最小20字节，最大60字节 |
| 应用场景 | 适用于实时应用，例如视频会议、直播 | 适用于要求可靠传输的应用，例如文件传输 |


## 3.TCP和UDP的使用场景
+ **TCP应用场景：** **<font style="color:#ECAA04;">效率要求相对低，但对准确性要求相对高的场景</font>**。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：**<font style="color:#ECAA04;">文件传输</font>**（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
+ **UDP应用场景：** **<font style="color:#ECAA04;">效率要求相对高，对准确性要求相对低的场景</font>**。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）

## 4.UDP为什么不可靠？TCP为什么可靠？
UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：

+ 不保证消息交付：**<font style="color:#ECAA04;">不确认，不重传，无超时</font>**
+ 不保证交付顺序：**<font style="color:#ECAA04;">不设置包序号，不重排</font>**，不会发生队首阻塞
+ 不跟踪连接状态：不必建立连接或重启状态机
+ 不进行拥塞控制：不内置客户端或网络反馈机制

TCP在传输数据之前需要简历连接，收到报文需要进行确认，具有拥塞控制和超时重传机制。

+ 面向连接
+ 接受确认机制
+ 超时重传机制
+ 会给每个数据段编号，保证传递到达的顺序
+ 拥塞控制

## 5.TCP重传机制
由于TCP的下层网络（网络层）可能出现**<font style="color:#ECAA04;">丢失、重复或失序</font>**的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是**<font style="color:#ECAA04;">基于时间</font>**，二是**<font style="color:#ECAA04;">基于确认信息</font>**。(根据时间判断或ACK报文判断是否重传)



**<font style="color:#ECAA04;">TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</font>**

## <font style="color:#000000;">6.TCP的拥塞控制</font>
TCP的拥塞控制机制主要是以下四种机制：

+ 慢启动（慢开始）
+ 拥塞避免
+ 快速重传
+ 快速恢复

**（1）慢启动（慢开始）**

+ 在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）
+ 思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。
+ 为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)
    - 当cnwd < ssthresh，使用慢开始算法
    - 当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
    - 当cnwd > ssthresh，使用拥塞避免算法

**（2）拥塞避免**

+ 拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为**<font style="color:#ECAA04;">按线性增长</font>**，使网络不容易出现阻塞。
+ 思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一
+ 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:  
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952123-62276cba-d882-46c9-8a1c-70655dc501af.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)  
其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。

**（3）快速重传**

+ 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只**<font style="color:#ECAA04;">要连续收到三个重复确认就立即重传对方尚未收到的报文段</font>**，而不必继续等待设置的重传计时器时间到期。
+ 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量

**（4）快速恢复**

+ 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
+ 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。  
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

## 7.TCP流量控制
一般来说，**<font style="color:#ECAA04;">流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收</font>**。TCP采用大小可变的**<font style="color:#ECAA04;">滑动窗口</font>**进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。

+ 当一个连接建立时，连接的**<font style="color:#ECAA04;">每一端分配一个缓冲区</font>**来保存输入的数据，并将缓冲区的大小发送给另一端。
+ 当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）
+ 如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。
+ 如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。

## 8.TCP的可靠传输机制
TCP 的可靠传输机制是**<font style="color:#ECAA04;">基于连续 ARQ 协议和滑动窗口协议</font>**的。



TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中**<font style="color:#ECAA04;">包含了已经发送但未确认的报文段和允许发送但还未发送的报文段</font>**，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 **<font style="color:#ECAA04;">如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置</font>**，此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么**<font style="color:#ECAA04;">发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发送但确认的报文段</font>**。



接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。**<font style="color:#ECAA04;">如果收到了一个乱序的报文段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答</font>**。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。



发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，**<font style="color:#ECAA04;">TCP 就是通过控制发送窗口的长度来控制报文段的发送速率。</font>**



但是TCP协议并不完全和滑动窗口协议相同，因为许多的TCP实现会将失序的报文段给缓存起来，并且发生重传时，只会重传一个报文段，因此 TCP 协议的可靠传输机制更像是**<font style="color:#ECAA04;">窗口滑动协议和选择重传协议</font>**的一个混合体。

## 9.TCP三次握手和四次握手
### （1）三次握手
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行**<font style="color:#ECAA04;">三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</font>**。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。



刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

+ 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。

> 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
>

+ 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

> 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y
>

+ 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。
>



**<font style="color:#ECAA04;">那为什么要三次握手呢？两次不行吗？</font>**

+ **<font style="color:#ECAA04;">为了确认双方的接收能力和发送能力都正常</font>**
+ 如果是用两次握手，则会出现下面这种情况：

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，**<font style="color:#ECAA04;">但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接</font>**，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。
>



**简单来说就是以下三步：**

+ **第一次握手：**客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。
+ **第二次握手：**服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。
+ **第三次握手：**当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。



TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。

### （2）四次挥手
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

+ 第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

> 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
>

+ 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

> 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
>

+ 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

> 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
>

+ 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
>

**那为什么需要四次挥手呢？**

> 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。
>



**简单来说就是以下四步：**

+ **第一次挥手**：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。
+ **第二次挥手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。
+ **第三次挥手**：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。
+ **第四次挥手：**客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。**<font style="color:#ECAA04;">该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。</font>**当服务端收到确认应答后，也便进入 CLOSED 状态。



**<font style="color:#ECAA04;">TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态</font>**。



最后一次挥手中，**<font style="color:#ECAA04;">客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭</font>**。

## 10.TCP粘包问题
默认情况下,**<font style="color:#ECAA04;"> TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们</font>**. 如果短时间有多个数据发送, 会**<font style="color:#ECAA04;">缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能</font>**. 



如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包. 



下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: 

A. 先接收到 data1, 然后接收到 data2 . 

B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. 

C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. 

D. ⼀次性接收到了 data1 和 data2 的全部数据. 



其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有: 

+ **多次发送之前间隔⼀个等待时间**：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理. 
+ **<font style="color:#ECAA04;">关闭Nagle算法</font>**：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)  
+ **进⾏****<font style="color:#ECAA04;">封包/拆包</font>****：****<font style="color:#ECAA04;">封包/拆包</font>**是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, **<font style="color:#ECAA04;">于其前/后放⼀些有特征的数据, 然后收到数据的时候根据特征数据分割出来各个数据包</font>**。

## 11.UDP不粘包
+ TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据 
+ UDP**<font style="color:#ECAA04;">具有保护消息边界</font>**，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。

# HTTP/HTTPS
## 1.HTTP
### 1）请求与响应
#### (1) 请求头和响应头
**HTTP Request Header 常见的****<font style="color:#ECAA04;">请求头</font>****：**

+ Accept: 浏览器能够处理的内容类型
+ Accept-Charset: 浏览器能够显示的字符集
+ Accept-Encoding：浏览器能够处理的压缩编码
+ Accept-Language：浏览器当前设置的语言
+ Connection：**<font style="color:#ECAA04;">浏览器与服务器之间连接的类型</font>**
+ Cookie：**<font style="color:#ECAA04;">当前页面设置的任何Cookie</font>**
+ Host：**<font style="color:#ECAA04;">发出请求的页面所在的域</font>**
+ Referer：发出请求的页面的URL
+ User-Agent：浏览器的用户代理字符串



**HTTP Responses Header 常见的****<font style="color:#ECAA04;">响应头</font>****：**

+ Date：表示消息发送的时间，时间的描述格式由rfc822定义
+ server: 服务器名称
+ Connection：**<font style="color:#ECAA04;">浏览器与服务器之间连接的类型</font>**
+ Cache-Control：**<font style="color:#ECAA04;">控制HTTP缓存</font>**
+ content-type: 表示后面的**<font style="color:#ECAA04;">文档属于什么MIME类型</font>**



常见的 Content-Type 属性值有以下四种：

（1）application/x-www-form-urlencoded：浏览器的**<font style="color:#ECAA04;">原生form表单</font>**，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，**<font style="color:#ECAA04;">通常表单上传文件时使用该种方式</font>**。

（3）application/json：服务器**<font style="color:#ECAA04;">消息主体是序列化后的 JSON 字符串</font>**。

（4）text/xml：该种方式主要用**<font style="color:#ECAA04;">来提交 XML 格式的数据</font>**。

#### (2) 请求报文和响应报文
请求报⽂有4部分组成: 

+ 请求⾏ 
+ 请求头部 
+ 空⾏
+ 请求体 

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907508156-a82d09e4-00bf-4dc7-a3a3-1ae75481754e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**其中：**

（1）请求⾏包括：**<font style="color:#ECAA04;">请求⽅法字段、URL字段、HTTP协议版本字段</font>**。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 

（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  

+ User-Agent：产⽣请求的**<font style="color:#ECAA04;">浏览器类型</font>**。 
+ Accept：客户端**<font style="color:#ECAA04;">可识别的内容类型列表</font>**。 
+ Host：**<font style="color:#ECAA04;">请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机</font>**。 

（3）请求体: post put等请求携带的数据 

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907573585-6651540d-9dee-4b33-a97f-dee1b31f231c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**响应报⽂有4部分组成: **

+ 响应⾏ 
+ 响应头 
+ 空⾏
+ 响应体 

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907658281-b3a51c98-db27-45be-9b0c-fb2c7665b015.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 响应⾏：由**<font style="color:#ECAA04;">网络协议版本，状态码和状态码的原因短语组成</font>**，例如 HTTP/1.1 200 OK 。 
+ 响应头：响应部⾸组成 
+ 响应体：服务器响应的数据 

#### (3) 请求方法
+ GET: 向服务器获取数据；
+ POST：将实体提交到指定的资源，通常会造成服务器资源的修改；
+ PUT：上传文件，更新数据；
+ DELETE：删除服务器上的对象；
+ HEAD：**<font style="color:#ECAA04;">获取报文首部</font>**，与GET相比，**<font style="color:#ECAA04;">不返回报文主体部分</font>**；
+ OPTIONS：**<font style="color:#ECAA04;">询问支持的请求方法，用来跨域请求</font>**；
+ CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
+ TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。

#### (4) GET、POST、PUT的区别
Post 和 Get 是 HTTP 请求的两种方法，其区别如下：

+ **应用场景：**GET 请求是一个幂等的请求，一般**<font style="color:#ECAA04;">Get请求用于对服务器资源不会产生影响的场景</font>**，比如说请求一个网页的资源。而Post不是一个幂等的请求，**<font style="color:#ECAA04;">一般用于对服务器资源会产生影响的情景</font>**，比如注册用户这一类的操作。
+ **是否缓存：**因为两者应用场景不同，**<font style="color:#ECAA04;">浏览器一般会对Get请求缓存，但很少对 Post 请求缓存。</font>**
+ **发送的报文格式：**Get请求的报文中**<font style="color:#ECAA04;">实体部分为空，Post请求的报文中实体部分一般为向服务器发送的数据</font>**。
+ **安全性：**Get 请求可以将**<font style="color:#ECAA04;">请求的参数放入url中向服务器发送</font>**，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
+ **请求长度：**浏览器由于对 url 长度的限制，所以**<font style="color:#ECAA04;">会影响get请求发送数据时的长度</font>**。这个限制是浏览器规定的，并不是RFC规定的。
+ **参数类型：**post 的参数传递支持更多的数据类型。



POST和PUT请求的区别：

+ PUT请求是向服务器端发送数据，从而修改数据的内容，但是**<font style="color:#ECAA04;">不会增加数据的种类等</font>**，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**<font style="color:#ECAA04;">更新数据</font>**）
+ POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它**<font style="color:#ECAA04;">会创建新的内容</font>**。（可以理解为是**<font style="color:#ECAA04;">创建数</font>****据**）



#### (5) GET方法URL长度限制的原因
实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个**<font style="color:#ECAA04;">限制是特定的浏览器及服务器对它的限制</font>**。

IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要**<font style="color:#ECAA04;">URL不超过2083字节，那么在所有浏览器中工作都不会有问题</font>**。

```javascript
GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）
```

下面看一下主流浏览器对get方法中url的长度限制范围：

+ Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。
+ Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。
+ Safari (Browser)：URL最大长度限制为 80,000 个字符。
+ Opera (Browser)：URL最大长度限制为 190,000 个字符。
+ Google (chrome)：URL最大长度限制为 8182 个字符。



主流的服务器对get方法中url的长度限制范围：

+ Apache (Server)：能接受最大url长度为8192个字符。
+ Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。



根据上面的数据，可以知道，**<font style="color:#ECAA04;">get方法中的URL长度最长不超过2083个字符</font>**，这样所有的浏览器和服务器都可能正常工作。

#### (6) OPTIONS请求方法及使用场景
OPTIONS是除了GET和POST之外的其中一种HTTP请求方法。



OPTIONS方法是用于请求获得**<font style="color:#ECAA04;">由</font>**`**<font style="color:#ECAA04;">Request-URI</font>**`**<font style="color:#ECAA04;">标识的资源在请求/响应的通信过程中可以使用的功能选项</font>**。通过这个方法，客户端可以**<font style="color:#ECAA04;">在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</font>**。该请求方法的响应不能缓存。



OPTIONS请求方法的**<font style="color:#ECAA04;">主要用途</font>**有两个：

+ **<font style="color:#ECAA04;">获取服务器支持的所有HTTP请求方法</font>**；
+ **<font style="color:#ECAA04;">用来检查访问权限。</font>**例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

#### (7) 对keep-alive的理解
HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是**<font style="color:#ECAA04;">短连接</font>**。当使用Keep-Alive模式时，**<font style="color:#ECAA04;">Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是长连接</font>**。其使用方法如下：

+ HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送`Connection: keep-alive`字段。若想断开keep-alive连接，需发送`Connection:close`字段；
+ HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送`Connection：close`首部字段。



Keep-Alive的**<font style="color:#ECAA04;">建立过程</font>**：

+ 客户端向服务器在发送请求报文同时在首部**<font style="color:#ECAA04;">添加发送Connection字段</font>**
+ 服务器收到请求并处理 Connection字段
+ 服务器**<font style="color:#ECAA04;">回送Connection:Keep-Alive字段给客户端</font>**
+ 客户端接收到Connection字段
+ Keep-Alive连接建立成功



**<font style="color:#ECAA04;">服务端自动断开过程（也就是没有keep-alive）</font>**：

+ 客户端向服务器只是发送内容报文（**<font style="color:#ECAA04;">不包含Connection字段</font>**）
+ 服务器收到请求并处理
+ 服务器返回客户端请求的资源并关闭连接
+ 客户端接收资源，**<font style="color:#ECAA04;">发现没有Connection字段，断开连接</font>**



**<font style="color:#ECAA04;">客户端请求断开连接过程</font>**：

+ 客户端向服务器**<font style="color:#ECAA04;">发送Connection:close字段</font>**
+ 服务器收到请求并处理connection字段
+ 服务器回送响应资源并断开连接
+ 客户端接收资源并断开连接



开启Keep-Alive的**<font style="color:#ECAA04;">优点</font>****：**

+ 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
+ 允许请求和应答的HTTP管线化； 
+ **<font style="color:#ECAA04;">降低拥塞控制</font>** （TCP连接减少了）； 
+ **<font style="color:#ECAA04;">减少了后续请求的延迟</font>**（⽆需再进⾏握⼿）； 
+ 报告错误⽆需关闭TCP连接；



开启Keep-Alive的**缺点**：

+ 长时间的Tcp连接容易导致**<font style="color:#ECAA04;">系统资源无效占用，浪费系统资源</font>**。

### 2）状态码
状态码的类别：

| **类别** | **原因** | **描述** |
| :---: | :---: | :---: |
| 1xx | Informational(信息性状态码) | 接受的请求**<font style="color:#ECAA04;">正在处理</font>** |
| 2xx | Success(成功状态码) | 请求**<font style="color:#ECAA04;">正常处理</font>**完毕 |
| 3xx | Redirection(重定向状态码) | 需要**<font style="color:#ECAA04;">进行附加操作一完成</font>**请求 |
| 4xx | Client Error (客户端错误状态码) | 服务器**<font style="color:#ECAA04;">无法处理</font>**请求 |
| 5xx | Server Error(服务器错误状态码) | 服务器处理请求出错 |


#### 1.状态码2XX表示请求被正常处理了。
##### （1）200 OK
200 OK表示客户端发来的请求被服务器端正常处理了。

##### （2）204 No Content
该状态码表示客户端发送的请求已经在服务器端正常处理了，但是**<font style="color:#ECAA04;">没有返回的内容</font>**，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

##### （3）206 Partial Content
该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

#### 2. 3XX (Redirection 重定向状态码)
3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

##### <font style="color:#ECAA04;">（1）301 Moved Permanently</font>
**<font style="color:#ECAA04;">永久重定向</font>**。

该状态码表示**<font style="color:#ECAA04;">请求的资源已经被分配了新的 URI</font>**，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。



**使用场景：**

+ 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
+ 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

##### （2）302 Found
**<font style="color:#ECAA04;">临时重定向</font>**。

该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说**<font style="color:#ECAA04;">已移动的资源对应的 URI 将来还有可能发生改变。</font>**若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。



**使用场景：**

+ 当我们在做活动时，登录到首页自动重定向，进入活动页面。
+ 未登陆的用户访问用户中心重定向到登录页面。
+ 访问404页面重新定向到首页。

##### （3）303 See Other
该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。



303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。



注意：

+ 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。
+ 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。

##### （4）304 Not Modified
**<font style="color:#ECAA04;">浏览器缓存相关</font>**。

该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。



带条件的请求（Http 条件请求）：使用 Get方法请求，请求报文中包含（`if-match`、`if-none-match`、`if-modified-since`、`if-unmodified-since`、`if-range`）中任意首部。



**<font style="color:#ECAA04;">状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。</font>**返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。

##### （5）307 Temporary Redirect
**<font style="color:#ECAA04;">307表示临时重定向</font>**。该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。



307 会遵守浏览器标准，**<font style="color:#ECAA04;">不会从 POST 变成 GET</font>**。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。

#### 3. 4XX (Client Error 客户端错误状态码)
4XX 的响应结果表明客户端是发生错误的原因所在。

##### （1）400 Bad Request
该状态码表示**<font style="color:#ECAA04;">请求报文中存在语法错误</font>**。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

##### （2）401 Unauthorized
该状态码表示**<font style="color:#ECAA04;">发送的请求需要有通过 HTTP 认证</font>**(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则**<font style="color:#ECAA04;">表示用户认证失败</font>**



返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。



以下情况会出现401：

+ 401.1 - **<font style="color:#ECAA04;">登录失败</font>**。
+ 401.2 - **<font style="color:#ECAA04;">服务器配置导致登录失败</font>**。
+ 401.3 - 由于 ACL 对资源的限制而未获得授权。
+ 401.4 - 筛选器**<font style="color:#ECAA04;">授权失败</font>**。
+ 401.5 - ISAPI/CGI 应用程序授权失败。
+ 401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。

##### （3）403 Forbidden
该状态码表明**<font style="color:#ECAA04;">请求资源的访问被服务器拒绝了</font>**，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。**<font style="color:#ECAA04;">该访问是永久禁止的</font>**，并且与应用逻辑密切相关。



IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：

+ 403.1 - 执行访问被禁止。
+ 403.2 - 读访问被禁止。
+ 403.3 - 写访问被禁止。
+ 403.4 - 要求 SSL。
+ 403.5 - 要求 SSL 128。
+ 403.6 - IP 地址被拒绝。
+ 403.7 - 要求客户端证书。
+ 403.8 - 站点访问被拒绝。
+ 403.9 - 用户数过多。
+ 403.10 - 配置无效。
+ 403.11 - 密码更改。
+ 403.12 - 拒绝访问映射表。
+ 403.13 - 客户端证书被吊销。
+ 403.14 - 拒绝目录列表。
+ 403.15 - 超出客户端访问许可。
+ 403.16 - 客户端证书不受信任或无效。
+ 403.17 - 客户端证书已过期或尚未生效
+ 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。
+ 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。
+ 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。

##### （4）404 Not Found
**<font style="color:#ECAA04;">该状态码表明服务器上无法找到请求的资源</font>**。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

以下情况会出现404：

+ 404.0 -（无） – 没有找到文件或目录。
+ 404.1 - 无法在所请求的端口上访问 Web 站点。
+ 404.2 - Web 服务扩展锁定策略阻止本请求。
+ 404.3 - MIME 映射策略阻止本请求。

##### （5）405 Method Not Allowed
该状态码表示客户端请求的方法虽然能被服务器识别，**<font style="color:#ECAA04;">但是服务器禁止使用该方法</font>**。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。**<font style="color:#ECAA04;">客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法</font>**, 如下

```javascript
Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE
```

#### 4. 5XX (Server Error 服务器错误状态码)
5XX 的响应结果表明服务器本身发生错误.

##### （1）500 Internal Server Error
该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

##### （2）502 Bad Gateway
该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：

+ 502.1 - CGI （通用网关接口）应用程序超时。
+ 502.2 - CGI （通用网关接口）应用程序出错。

##### （3）503 Service Unavailable
该状态码表明服务器暂时处于**<font style="color:#ECAA04;">超负载或正在进行停机维护，现在无法处理请求</font>**。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。



**使用场景：**

+ 服务器停机维护时，主动用503响应请求；
+ nginx 设置限速，超过限速，会返回503。

##### （4）504 Gateway Timeout
该状态码表示**<font style="color:#ECAA04;">网关或者代理的服务器无法在规定的时间内获得想要的响应。</font>**他是HTTP 1.1中新加入的。



使用场景：代码执行时间超时，或者发生了死循环。

#### 5. 总结
**（1）2XX 成功**

+ 200 OK，表示从客户端发来的请求在服务器端被正确处理
+ 204 No content，表示请求成功，但响应报文不含实体的主体部分
+ 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
+ 206 Partial Content，进行范围请求

**（2）3XX 重定向**

+ 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
+ 302 found，临时性重定向，表示资源临时被分配了新的 URL
+ 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
+ 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
+ 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**（3）4XX 客户端错误**

+ 400 bad request，请求报文存在语法错误
+ 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
+ 403 forbidden，表示对请求资源的访问被服务器拒绝
+ 404 not found，表示在服务器上没有找到请求的资源

**（4）5XX 服务器错误**

+ 500 internal sever error，表示服务器端在执行请求时发生了错误
+ 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
+ 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

#### 6.HTTP状态码304是多好还是少好
服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。



状态码304不应该认为是一种错误，而是对客户端**<font style="color:#ECAA04;">有缓存情况下</font>**服务端的一种响应。



搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。



**产生较多304状态码的原因：**

+ 页面**<font style="color:#ECAA04;">更新周期长或不更新</font>**
+ 纯**<font style="color:#ECAA04;">静态页面或强制生成静态html</font>**



**304状态码出现过多会造成以下问题：**

+ 网站快照停止；
+ 收录减少；
+ 权重下降。

### 3）浏览器请求过程
1. **解析URL**：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。
2. **缓存判断**：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求
3. **DNS解析**：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向**<font style="color:#ECAA04;">本地 DNS 服务器发起请求</font>**。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。**<font style="color:#ECAA04;">用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求</font>**。
4. **获取MAC地址**：当浏览器得到 IP 地址后，数据传输还**<font style="color:#ECAA04;">需要知道目的主机 MAC 地址</font>**，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，**<font style="color:#ECAA04;">获取的 IP 地址作为目的地址</font>**。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，**<font style="color:#ECAA04;">目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址</font>**。
5. **TCP三次握手：**下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
6. **HTTPS握手：**如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
7. **返回数据：**当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
8. **页面渲染：****<font style="color:#ECAA04;">浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞</font>**。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
9. **TCP四次挥手：**最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

### 4）HTTP 1.0、HTTP 1.1、HTTP 2.0、HTTP 3.0
**HTTP 1.0和 HTTP 1.1 有以下区别：**

+ **连接方面**，**<font style="color:#ECAA04;">http1.0</font>**<font style="color:#ECAA04;"> </font>默认使用**<font style="color:#ECAA04;">非持久连接</font>**，而**<font style="color:#ECAA04;"> http1.1 </font>**默认使用**<font style="color:#ECAA04;">持久连接</font>**。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
+ **资源请求方面**，在 **<font style="color:#ECAA04;">http1.0</font>** 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且**<font style="color:#ECAA04;">不支持断点续传功能</font>**，http1.1 则在请求头**<font style="color:#ECAA04;">引入了range头域</font>**，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
+ **<font style="color:#ECAA04;">缓存方面</font>**，在http1.0中主要使用header里的**<font style="color:#ECAA04;">If-Modified-Since、Expires来做为缓存判断的标准</font>**，http1.1 则引入了更多的缓存控制策略，例如 **<font style="color:#ECAA04;">Etag、If-Unmodified-Since、If-Match、If-None-Match </font>**等更多可供选择的缓存头来控制缓存策略。
+ http1.1 中**<font style="color:#ECAA04;">新增了host字段</font>**，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
+ http1.1 相对于 http1.0 还新增了很多**<font style="color:#ECAA04;">请求方法</font>**，如**<font style="color:#ECAA04;">PUT</font>**、HEAD、OPTIONS等。

**HTTP 1.1和 HTTP 2.0 有以下区别**：

+ **<font style="color:#ECAA04;">二进制协议</font>**：HTTP/2 是一个**<font style="color:#ECAA04;">二进制协议</font>**。在 HTTP/1.1 版中，**<font style="color:#ECAA04;">报文的头信息必须是文本（ASCII 编码）</font>**，数据体可以是文本，也可以是二进制。**<font style="color:#ECAA04;">HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧</font>**。 帧的概念是它实现多路复用的基础。
+ **<font style="color:#ECAA04;">多路复用</font>****：**HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，**<font style="color:#ECAA04;">客户端和服务器都可以同时发送多个请求或回应</font>**，而且不用按照顺序一一发送，这样就避免了"队头堵塞"<sup>【1】</sup>的问题。
+ **<font style="color:#ECAA04;">数据流</font>****：**HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。**<font style="color:#ECAA04;">每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流</font>**。
+ **<font style="color:#ECAA04;">头信息压缩</font>****：**HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
+ **<font style="color:#ECAA04;">服务器推送</font>****：**HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是**<font style="color:#ECAA04;"> http2 下服务器主动推送的是静态资源</font>**，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

**【1】队头堵塞：**

> 队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。
>

**HTTP 3.0的特点：**

HTTP/3**<font style="color:#ECAA04;">基于UDP协议</font>**实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。

![](https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

1. **<font style="color:#ECAA04;">流量控制、传输可靠性功能</font>**：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
2. **<font style="color:#ECAA04;">集成TLS加密功能</font>**：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
3. **<font style="color:#ECAA04;">多路复用</font>**：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。

![](https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-5d0a5de2-00db-425e-8b21-0cc4bbb54b24.webp?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

4. **<font style="color:#ECAA04;">快速握手</font>**：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。

## 2.HTTPS
### 1）什么是HTTPS协议
超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是**<font style="color:#ECAA04;">提供对网站服务器的身份认证，保护交换数据的隐私与完整性</font>**。

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_43%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

HTTP协议采用**<font style="color:#ECAA04;">明文传输</font>**信息，存在**<font style="color:#ECAA04;">信息窃听</font>**<font style="color:#ECAA04;">、</font>**<font style="color:#ECAA04;">信息篡改</font>**和**<font style="color:#ECAA04;">信息劫持</font>**的风险，而协议TLS/SSL具有**<font style="color:#ECAA04;">身份验证</font>**<font style="color:#ECAA04;">、</font>**<font style="color:#ECAA04;">信息加密</font>**和**<font style="color:#ECAA04;">完整性校验</font>**的功能，可以避免此类问题发生。



安全层的主要职责就是**<font style="color:#ECAA04;">对发起的HTTP请求的数据进行加密操作 </font>**和 **<font style="color:#ECAA04;">对接收到的HTTP的内容进行解密操作</font>**。

### 2）TLS/SSL的工作原理
**TLS/SSL**全称**安全传输层协议**（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。



TLS/SSL的功能实现主要依赖三类基本算法：**散列函数hash**、**对称加密**、**非对称加密**。这三类算法的作用如下：

+ **<font style="color:#ECAA04;">基于散列函数验证信息的完整性</font>**
+ 对称加密算法采用协商的秘钥对**<font style="color:#ECAA04;">数据加密</font>**
+ 非对称加密实现**<font style="color:#ECAA04;">身份认证</font>**和**<font style="color:#ECAA04;">秘钥协商</font>**

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

#### （1）散列函数hash
常见的散列函数有**<font style="color:#ECAA04;">MD5、SHA1、SHA256</font>**。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，**<font style="color:#ECAA04;">任何数据的修改都会改变散列函数的结果</font>**，可以用于**<font style="color:#ECAA04;">防止信息篡改并验证数据的完整性</font>**。



**特点：**在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。

#### （2）对称加密
对称加密的方法是，**<font style="color:#ECAA04;">双方使用同一个秘钥对数据进行加密和解密</font>**。但是对称加密的存在一个**<font style="color:#ECAA04;">问题，就是如何保证秘钥传输的安全性</font>**，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。



常见的对称加密算法有**<font style="color:#ECAA04;">AES-CBC、DES、3DES、AES-GCM</font>**等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。



**特点：**对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。

#### （3）非对称加密
非对称加密的方法是，我们拥有两个秘钥，**<font style="color:#ECAA04;">一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。</font>**用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个**<font style="color:#ECAA04;">缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题</font>**。



常见的非对称加密算法有**<font style="color:#ECAA04;">RSA、ECC、DH</font>**等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。



**特点：**非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。



综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。

### 3）数字证书
首先**<font style="color:#ECAA04;">使用一种Hash算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名</font>**。最后将原始的信息和签名合在一起，称为**<font style="color:#ECAA04;">数字证书</font>**。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。



这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

### 4）握手过程
HTTPS的通信过程如下：

1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息

![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743511286907-a54dbb51-2dcf-45ef-9850-f9bf78ae35fe.png)

### 5）HTTPS的特点
HTTPS的**<font style="color:#ECAA04;">优点</font>**如下：

+ 使用HTTPS协议**<font style="color:#ECAA04;">可以认证用户和服务器</font>**，确保数据发送到正确的客户端和服务器；
+ 使用HTTPS协议可以进行**<font style="color:#ECAA04;">加密传输、身份认证</font>**，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；
+ HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；



HTTPS的**<font style="color:#ECAA04;">缺点</font>**如下：

+ HTTPS需要做服务器和客户端双方的加密个解密处理，**<font style="color:#ECAA04;">耗费更多服务器资源，过程复杂</font>**；
+ HTTPS协议**<font style="color:#ECAA04;">握手阶段比较费时，增加页面的加载时间</font>**；
+ **<font style="color:#ECAA04;">SSL证书是收费的，功能越强大的证书费用越高</font>**；
+ HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；
+ SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。

# DNS
## 是什么
**概念**： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到IP地址的转换服务，就是我们常说的域名系统。它**<font style="color:#ECAA04;">是一个由分层的DNS服务器组成的分布式数据库</font>**，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。



**作用**： 将**<font style="color:#ECAA04;">域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址</font>**。

## DNS同时使用TCP和UDP协议?
**<font style="color:#ECAA04;">DNS占用53号端口，同时使用TCP和UDP协议</font>****。**

（1）在**<font style="color:#ECAA04;">区域传输的时候使用TCP协议</font>**

+ 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
+ TCP是一种可靠连接，保证了数据的准确性。

（2）在**<font style="color:#ECAA04;">域名解析的时候使用UDP协议</font>**

+ 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

## DNS完整的查询过程
DNS服务器解析域名的过程：

+ 首先会在**<font style="color:#ECAA04;">浏览器的缓存</font>**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
+ 将请求发送给**<font style="color:#ECAA04;">本地DNS服务器</font>**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
+ 本地DNS服务器向**<font style="color:#ECAA04;">根域名服务器</font>**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
+ 本地DNS服务器向**<font style="color:#ECAA04;">顶级域名服务器</font>**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
+ 本地DNS服务器向**<font style="color:#ECAA04;">权威域名服务器</font>**发送请求，域名服务器返回对应的结果
+ 本地DNS服务器将返回结果保存在缓存中，便于下次使用
+ 本地DNS服务器将返回结果返回给浏览器

![](https://cdn.nlark.com/yuque/0/2025/png/43189118/1743512216969-5232a97d-fb61-4839-a543-ac95c651d13c.png)



比如要查询 [www.baidu.com](http://www.baidu.com/) 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。

## 迭代查询和递归查询
实际上，DNS解析是一个包含迭代查询和递归查询的过程。

+ **<font style="color:#ECAA04;">递归查询</font>**指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。**<font style="color:#ECAA04;">使用递归查询，用户只需要发出一次查询请求。</font>**
+ **<font style="color:#ECAA04;">迭代查询</font>**指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。**<font style="color:#ECAA04;">使用迭代查询，用户需要发出多次的查询请求。</font>**



一般我们**<font style="color:#ECAA04;">向本地 DNS 服务器发送请求的方式就是递归查询</font>**，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而**<font style="color:#ECAA04;">本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程</font>**，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。

## DNS记录和报文
DNS 服务器中以**<font style="color:#ECAA04;">资源记录的形式存储信息</font>**，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为

```http
（Name，Value，Type，TTL）
```

其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。



常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：

+ 如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。
+ 如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。
+ 如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。
+ 如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。

# WebSocket
## 1. 对 WebSocket 的理解
WebSocket是HTML5提供的一种浏览器与服务器进行**<font style="color:#ECAA04;">全双工通讯</font>**的网络技术，属于应用层协议。它**<font style="color:#ECAA04;">基于TCP传输协议</font>**，并复用HTTP的握手通道。**<font style="color:#ECAA04;">浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输</font>**。



WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：**<font style="color:#ECAA04;">服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息</font>****。**



**<font style="color:#ECAA04;">WebSocket原理</font>**：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。



**<font style="color:#ECAA04;">WebSocket 特点的如下：</font>**

+ 支持**<font style="color:#ECAA04;">双向通信，实时性更强</font>**
+ 可以**<font style="color:#ECAA04;">发送文本，也可以发送二进制数据</font>**
+ 建立在TCP协议之上，服务端的实现比较容易
+ 数据格式比较轻量，性能开销小，通信高效
+ **<font style="color:#ECAA04;">没有同源限制，客户端可以与任意服务器通信</font>**
+ 协议**<font style="color:#ECAA04;">标识符是ws（如果加密，则为wss），服务器网址就是 URL</font>**
+ 与 HTTP 协议有着良好的兼容性。**<font style="color:#ECAA04;">默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</font>**。



**Websocket的使用方法如下：**



在客户端中：

```javascript
// 在index.html中直接写WebSocket，设置服务端的端口号为 9999
let ws = new WebSocket('ws://localhost:9999');
// 在客户端与服务端建立连接后触发
ws.onopen = function() {
    console.log("Connection open."); 
    ws.send('hello');
};
// 在服务端给客户端发来消息的时候触发
ws.onmessage = function(res) {
    console.log(res);       // 打印的是MessageEvent对象
    console.log(res.data);  // 打印的是收到的消息
};
// 在客户端与服务端建立关闭后触发
ws.onclose = function(evt) {
  console.log("Connection closed.");
}; 
```

## 2. 即时通讯的实现：短轮询、长轮询、SSE和WebSocket间的区别？
短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。



**<font style="color:#ECAA04;">短轮询的基本思路</font>**：<font style="color:#ECAA04;">浏览器每隔一段时间向服务器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。</font>**这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于**<font style="color:#ECAA04;">需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源</font>**。当用户增加时，服务器端的压力就会变大，这是很不合理的。（**<font style="color:#4861E0;">这个就是每隔一段时间请求一次，保持实时性</font>**）



**<font style="color:#ECAA04;">长轮询的基本思路</font>**：**首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，**<font style="color:#ECAA04;">服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</font>**客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。(**<font style="color:#4861E0;">收集请求，返回改变的请求，或达到时间限制返回，保证实时性</font>**)



**<font style="color:#ECAA04;">SSE 的基本思想</font>**：<font style="color:#ECAA04;">服务器使用流信息向服务器推送信息</font>**。严格地说，http协议无法做到服务器主动推送信息。但是，有一种变通方法，就是**<font style="color:#ECAA04;">服务器向客户端声明，接下来要发送的是流信息</font>**。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE就是利用这种机制，使用流信息向浏览器推送信息。它基于http协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的http请求，相比之下节约了资源。(**<font style="color:#4861E0;">服务端向客户端声明发送的是一个流数据，不是一次性数据，客户端就不会关闭连接，一直等待数据发送过来</font>**)



**<font style="color:#ECAA04;">WebSocket</font>**是HTML5定义的一个新协议议，与传统的http协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而**<font style="color:#ECAA04;">SSE的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了</font>**。



**上面的四个通信协议，**<font style="color:#ECAA04;">前三个都是基于HTTP协议的</font>。



对于这四种即使通信协议，从性能的角度来看：

**<font style="color:#ECAA04;">WebSocket > 长连接（SEE） > 长轮询 > 短轮询</font>**

但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：

**<font style="color:#ECAA04;">短轮询 > 长轮询 > 长连接（SEE） > WebSocket</font>**

所以，还是要根据具体的使用场景来判断使用哪种方式。

