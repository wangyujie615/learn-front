![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/43189118/1743573025155-484dcc5b-b8cc-4a0d-9171-184051da8aad.jpeg)

# 浏览器安全
## XSS
### （1）概念
XSS 攻击指的是**<font style="color:#ECAA04;">跨站脚本攻击</font>**，是一种代码注入攻击。攻击者**<font style="color:#ECAA04;">通过在网站注入恶意脚本</font>**，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。



XSS 的本质是因为**<font style="color:#ECAA04;">网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行</font>**。



攻击者可以通过这种攻击方式可以进行以下操作：

+ 获取页面的数据，如DOM、cookie、localStorage；
+ DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
+ 破坏页面结构；
+ 流量劫持（将链接指向某网站）；

### （2）攻击类型
XSS 可以分为**<font style="color:#ECAA04;">存储型</font>**、**<font style="color:#ECAA04;">反射型</font>**和**<font style="color:#ECAA04;">DOM型</font>**：

+ 存储型指的是<font style="color:#333333;">恶意脚本会</font>**<font style="color:#ECAA04;">存储在目标服务器</font>**<font style="color:#333333;">上，</font>**<font style="color:#ECAA04;">当浏览器请求数据时，脚本从服务器传回并执行</font>**<font style="color:#333333;">。</font>
+ 反射型指的是<font style="color:#333333;">攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，</font>**<font style="color:#ECAA04;">浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击</font>**<font style="color:#333333;">。 </font>
+ DOM 型指的**<font style="color:#ECAA04;">通过修改页面的 DOM 节点形成的 XSS</font>**<font style="color:#333333;">。</font>

**<font style="color:#000000;">1）存储型 XSS 的攻击步骤： </font>**

1. <font style="color:#000000;">攻击者将恶意代码提交到⽬标⽹站的数据库中。 </font>
2. <font style="color:#000000;">⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 </font><font style="color:#000000;">HTML </font><font style="color:#000000;">中返回给浏览器。 </font>
3. <font style="color:#000000;">⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </font>
4. <font style="color:#000000;">恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 </font>



<font style="color:#000000;">这种攻击常⻅于</font>**<font style="color:#ECAA04;">带有⽤户保存数据的⽹站功能</font>**<font style="color:#000000;">，如论坛发帖、商品评论、⽤户私信等。</font>



**<font style="color:#000000;">2）反射型 </font>****<font style="color:#000000;">XSS </font>****<font style="color:#000000;">的攻击步骤： </font>**

1. <font style="color:#000000;">攻击者构造出特殊的 </font><font style="color:#000000;">URL</font><font style="color:#000000;">，其中包含恶意代码。 </font>
2. <font style="color:#000000;">⽤户打开带有恶意代码的 URL 时，</font>**<font style="color:#ECAA04;">⽹站</font>****<font style="color:#117CEE;">服务端</font>****<font style="color:#ECAA04;">将恶意代码从URL中取出，拼接在HTML中返回给浏览器</font>**<font style="color:#000000;">。 </font>
3. <font style="color:#000000;">⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </font>
4. <font style="color:#000000;">恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 </font>



<font style="color:#000000;">反射型 XSS 跟存储型 XSS 的区别是：</font>**<font style="color:#ECAA04;">存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥</font>**<font style="color:#000000;">。 </font>



<font style="color:#000000;">反射型 XSS 漏洞常⻅于</font>**<font style="color:#ECAA04;">通过URL传递参数的功能</font>**<font style="color:#000000;">，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  </font>



**<font style="color:#000000;">3）DOM </font>**<font style="color:#000000;">型 </font><font style="color:#000000;">XSS </font><font style="color:#000000;">的攻击步骤：</font>

1. <font style="color:#000000;">攻击者构造出特殊的 </font><font style="color:#000000;">URL</font><font style="color:#000000;">，其中包含恶意代码。 </font>
2. <font style="color:#000000;">⽤户打开带有恶意代码的 </font><font style="color:#000000;">URL</font><font style="color:#000000;">。 </font>
3. <font style="color:#000000;">⽤户浏览器接收到响应后解析执⾏，</font>**<font style="color:#ECAA04;">前端JavaScript取出URL中的恶意代码并执⾏</font>**<font style="color:#000000;">。 </font>
4. <font style="color:#000000;">恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 </font>



<font style="color:#000000;">DOM 型 XSS 跟前两种 XSS 的区别：</font>**<font style="color:#ECAA04;">DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于</font>**<font style="color:#117CEE;">**服务端的安全漏洞**</font>

### <font style="color:#000000;">（3）防御</font>
可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：

+ 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，**<font style="color:#ECAA04;">不用服务器端拼接后返回</font>**（不使用服务端渲染）。
+ 另一种是对需要**<font style="color:#ECAA04;">插入到HTML中的代码做好充分的转义</font>**。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
+ **<font style="color:#ECAA04;">使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行</font>**，从而防止恶意代码的注入攻击。

> 1. CSP 指的是**<font style="color:#ECAA04;">内容安全策略，它的本质是建立一个白名单</font>**，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
> 2. 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 **<font style="color:#ECAA04;">Content-Security-Policy</font>**，一种是设置 meta 标签的方式**<font style="color:#ECAA04;"> <meta http-equiv="Content-Security-Policy"></font>**
>

+ **<font style="color:#ECAA04;">对一些敏感信息进行保护</font>**，比如 cookie 使用 **<font style="color:#ECAA04;">http-only</font>**，使得脚本无法获取。也可以**<font style="color:#ECAA04;">使用验证码</font>**，避免脚本伪装成用户执行一些操作。

## CSRF
### （1）概念
CSRF 攻击指的是**<font style="color:#ECAA04;">跨站请求伪造攻击</font>**，攻击者**<font style="color:#ECAA04;">诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求</font>**。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的**<font style="color:#ECAA04;">本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充</font>****。**

### （2）攻击类型
常见的 CSRF 攻击有三种：

+  **<font style="color:#ECAA04;">GET 类型的 CSRF 攻击</font>**，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
+ **<font style="color:#ECAA04;"> POST 类型的 CSRF 攻击</font>**，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
+ **<font style="color:#ECAA04;">链接类型的 CSRF 攻击</font>**，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

### （3）防御手段
**CSRF 攻击可以使用以下方法来防护：**

+ **<font style="color:#ECAA04;">进行同源检测</font>**，服务器**<font style="color:#ECAA04;">根据http请求头中origin或者referer信息来判断请求是否为允许访问的站点，从而对请求进行过滤</font>**。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（<font style="color:#333333;">Referer 字段会告诉服务器该网页是从哪个页面链接过来的</font>）**<font style="color:#2F4BDA;">(利用http头为origin)</font>**
+ **<font style="color:#ECAA04;">使用CSRF Token进行验证</font>**，**<font style="color:#ECAA04;">服务器向用户返回一个随机数Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的token ，然后服务器对这个token进行验证</font>**。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的session中没有保留这个token的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。**<font style="color:#2F4BDA;">（服务端返回cookie的同时返回一个token）</font>**
+ **<font style="color:#ECAA04;">对Cookie进行双重验证</font>**，服务器在用户访问网站页面时，**<font style="color:#ECAA04;">向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，</font>****<font style="color:#2F4BDA;">从cookie中取出这个字符串，添加到URL参数中</font>****<font style="color:#ECAA04;">，然后服务器通过对cookie中的数据和参数中的数据进行比较，来进行验证</font>**。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取cookie的特点。并且这种方法比CSRF Token的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。**<font style="color:#2F4BDA;">（请求时把cookie内容提取出来加入URL，服务器在请求时对比cookie内容和url内容）</font>**
+ **<font style="color:#ECAA04;">在设置cookie属性的时候设置Samesite ，限制cookie不能作为被第三方使用</font>**，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

## 中间人攻击
<font style="color:#000000;">中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，</font>**<font style="color:#ECAA04;">攻击者可以拦截通讯双⽅的通话并插⼊新的内容</font>**<font style="color:#000000;">。</font>



<font style="color:#000000;">攻击过程如下</font><font style="color:#000000;">: </font>

+ <font style="color:#000000;">客户端发送请求到服务端，请求被中间⼈截获 </font>
+ <font style="color:#000000;">服务器向客户端发送公钥 </font>
+ <font style="color:#000000;">中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个</font>**<font style="color:#ECAA04;">伪造的</font>**<font style="color:#000000;">公钥，发给客户端 </font>
+ <font style="color:#000000;">客户端收到伪造的公钥后，⽣成加密</font><font style="color:#000000;">hash</font><font style="color:#000000;">值发给服务器 </font>
+ <font style="color:#000000;">中间⼈获得加密</font><font style="color:#000000;">hash</font><font style="color:#000000;">值，⽤⾃⼰的私钥解密获得真秘钥</font><font style="color:#000000;">,</font><font style="color:#000000;">同时⽣成假的加密</font><font style="color:#000000;">hash</font><font style="color:#000000;">值，发给服务器 </font>
+ <font style="color:#000000;">服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端 </font>

## 网络劫持
<font style="color:#000000;">⽹络劫持分为两种</font><font style="color:#000000;">: </font>

<font style="color:#000000;">（1）</font>**<font style="color:#ECAA04;">DNS劫持</font>**<font style="color:#ECAA04;">:</font><font style="color:#000000;"> (输⼊京东被强制跳转到淘宝这就属于dns劫持) </font>

+ <font style="color:#000000;">DNS强制解析: 通过修改运营商的</font>**<font style="color:#ECAA04;">本地DNS记录</font>**<font style="color:#000000;">，来引导⽤户流量到缓存服务器</font>
+ <font style="color:#000000;">302</font><font style="color:#000000;">跳转的⽅式</font><font style="color:#000000;">: </font><font style="color:#000000;">通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的</font><font style="color:#000000;">,</font><font style="color:#000000;">再对劫持的内存发起302跳转的回复，引导⽤户获取内容 </font>

<font style="color:#000000;">（2）</font>**<font style="color:#ECAA04;">HTTP劫持</font>**<font style="color:#000000;">: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商</font>**<font style="color:#ECAA04;">会修改你的http响应内容</font>**<font style="color:#000000;">(即加⼴告) </font>



<font style="color:#000000;">DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是</font>**<font style="color:#ECAA04;">全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</font>**<font style="color:#000000;"> </font>

# <font style="color:#000000;">进程和线程</font>
## 进程和线程的概念
**<font style="color:#ECAA04;">进程是资源分配的最小单位，线程是CPU调度的最小单位。</font>**

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。**<font style="color:#ECAA04;">进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间</font>****。**



<font style="color:#000000;">如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</font>



<font style="color:#000000;">进程和线程之间的关系有以下四个特点：</font>

**（1）****<font style="color:#ECAA04;">进程中的任意一线程执行出错，都会导致整个进程的崩溃</font>****。**

**（2）****<font style="color:#ECAA04;">线程之间共享进程中的数据</font>****。**

**（3）****<font style="color:#ECAA04;">当一个进程关闭之后，操作系统会回收进程所占用的内存</font>****，**<font style="color:#000000;">当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</font>

**（4）****<font style="color:#ECAA04;">进程之间的内容相互隔离。</font>**<font style="color:#000000;">进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</font>



**Chrome浏览器的架构图**<font style="color:#000000;">：</font>

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603803289911-191cabf3-e7e2-4354-a83d-858668cc116f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

<font style="color:#000000;">从图中可以看出，最新的 Chrome 浏览器包括：</font>

+ <font style="color:#000000;">1 个浏览器主进程</font>
+ <font style="color:#000000;">1 个 GPU 进程</font>
+ <font style="color:#000000;">1 个网络进程</font>
+ <font style="color:#000000;">多个渲染进程</font>
+ <font style="color:#000000;">多个插件进程</font>



<font style="color:#000000;">这些进程的功能：</font>

+ **浏览器进程**<font style="color:#000000;">：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</font>
+ **渲染进程**<font style="color:#000000;">：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</font>
+ **GPU 进程**<font style="color:#000000;">：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</font>
+ **网络进程**<font style="color:#000000;">：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</font>
+ **插件进程**<font style="color:#000000;">：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</font>



<font style="color:#000000;">所以，</font>**<font style="color:#ECAA04;">打开一个网页，最少需要四个进程</font>**<font style="color:#000000;">：</font>**<font style="color:#ECAA04;">1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。</font>**<font style="color:#000000;">如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</font>



<font style="color:#000000;">虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</font>

+ **更高的资源占用**<font style="color:#000000;">：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</font>
+ **更复杂的体系架构**<font style="color:#000000;">：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</font>

## 进程和线程的区别
+ 进程可以看做独立应用，线程不能
+ 资源：**<font style="color:#ECAA04;">进程</font>**<font style="color:rgba(0, 0, 0, 0.75);">是cpu</font>**<font style="color:#ECAA04;">资源分配</font>**<font style="color:rgba(0, 0, 0, 0.75);">的最小单位（是能</font>**<font style="color:#ECAA04;">拥有资源和独立运行</font>**<font style="color:rgba(0, 0, 0, 0.75);">的最小单位）；</font>**<font style="color:#ECAA04;">线程</font>**<font style="color:rgba(0, 0, 0, 0.75);">是</font>**<font style="color:#ECAA04;">cpu调度</font>**<font style="color:rgba(0, 0, 0, 0.75);">的最小单位（线程是</font>**<font style="color:#ECAA04;">建立在进程的基础上的一次程序运行单位</font>**<font style="color:rgba(0, 0, 0, 0.75);">，一个进程中可以有多个线程）。</font>
+ **<font style="color:#ECAA04;">通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</font>**
+ 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
+ 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

## 浏览器渲染进程的线程有哪些
浏览器的渲染进程的线程总共有五种：

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603803289922-6462f252-aa33-4cf6-b541-d8bc2e285125.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**（1）****<font style="color:#ECAA04;">GUI渲染线程</font>**

负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要**<font style="color:#ECAA04;">重绘</font>**或由于某种操作引发**<font style="color:#ECAA04;">回流</font>**时，该线程就会执行。



注意：**<font style="color:#ECAA04;">GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</font>**。



**（2）****<font style="color:#ECAA04;">JS引擎线程</font>**

JS引擎线程也称为JS内核，负责处理Javascript脚本程序，**<font style="color:#ECAA04;">解析Javascript脚本，运行代码</font>**；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；



注意：**<font style="color:#ECAA04;">GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞</font>**。



**（3）事件触发线程**

**<font style="color:#ECAA04;">事件触发线程</font>**属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如**<font style="color:#ECAA04;">鼠标点击、AJAX异步请求</font>**等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；



注意：由于JS的单线程关系，所以这些**<font style="color:#ECAA04;">待处理队列中的事件都得排队等待JS引擎处理</font>**（当JS引擎空闲时才会去执行）；



**（4）定时器触发进程**

**<font style="color:#ECAA04;">定时器触发进程</font>**即**<font style="color:#ECAA04;">setInterval与setTimeout所在线程</font>**；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；



注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。



**（5）****<font style="color:#ECAA04;">异步http请求线程</font>**

+ XMLHttpRequest连接后通过浏览器新开一个线程请求；
+ 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

## 进程之前的通信方式
**（1）管道通信**

管道是一种最基本的进程间通信机制。**<font style="color:#ECAA04;">管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了</font>****。**



管道的特点：

+ 只能单向通信
+ 只能血缘关系的进程进行通信
+ 依赖于文件系统
+ 生命周期随进程
+ 面向字节流的服务
+ 管道内部提供了同步机制

**（2）消息队列通信**

**<font style="color:#ECAA04;">消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等</font>**<font style="color:#4D4D4D;">。</font>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。



使用消息队列进行进程间通信，可能**<font style="color:#ECAA04;">会受到数据块最大长度的限制约束</font>**等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

**（3）信号量通信**

共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。**<font style="color:#ECAA04;">信号量的本质就是一个计数器，用来实现进程之间的互斥与同步</font>**。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。

**（4）信号通信**

<font style="color:#333333;">信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</font>

**（5）共享内存通信**

**<font style="color:#ECAA04;">共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）</font>**<font style="color:#333333;">。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</font>

**（6）套接字通信**

上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用**<font style="color:#ECAA04;"> Socket 的通信方式</font>**了。

## 死锁的产生的原因？如何解决死锁问题？
所谓死锁，是指多个进程在运行过程中<font style="color:#ECAA04;">因争夺资源而造成的一种僵局</font>，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。



系统中的资源可以分为两类：

+ **<font style="color:#ECAA04;">可剥夺资源</font>**，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
+ **<font style="color:#ECAA04;">不可剥夺资源</font>**，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。



**产生死锁的原因：**

**（1）竞争资源**

+ 产生死锁中的竞争资源之一指的是**<font style="color:#ECAA04;">竞争不可剥夺资源</font>**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
+ 产生死锁中的竞争资源另外一种资源指的是**<font style="color:#ECAA04;">竞争临时资源</font>**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

**（2）进程间推进顺序非法**

若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



**产生死锁的必要条件：**

+ **<font style="color:#ECAA04;">互斥条件</font>**：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
+ **<font style="color:#ECAA04;">请求和保持条件</font>**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
+ **<font style="color:#ECAA04;">不剥夺条件</font>**：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
+ **<font style="color:#ECAA04;">环路等待条件</font>**：在发生死锁时，必然存在一个进程——资源的环形链。



**预防死锁的方法：(破环这四个条件)**

+ 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
+ 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请求保持条件）
+ 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
+ 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件

## 如何实现浏览器内多个标签页通信？
现多个标签页之间的通信，本质上都是**<font style="color:#ECAA04;">通过中介者模式</font>**来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：

+ **<font style="color:#ECAA04;">使用websocket协议</font>**，因为websocket协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。**<font style="color:#ECAA04;">标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发</font>**。
+ **<font style="color:#ECAA04;">使用ShareWorker的方式</font>**，shareWorker会**<font style="color:#ECAA04;">在页面存在的生命周期内创建一个唯一的线程</font>**，并且开启多个页面也只会使用同一个线程。这个时候**<font style="color:#ECAA04;">共享线程就可以充当中介者的角色</font>**。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
+ **<font style="color:#ECAA04;">使用localStorage的方式</font>**，我们可以在一个标签页对localStorage的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候localStorage对象就是充当的中介者的角色。
+ **<font style="color:#ECAA04;">使用postMessage方法</font>**，如果我们能够获得对应标签页的引用，就可以使用postMessage方法，进行通信。

## 对Service Worker的理解
Service Worker是运行在浏览器背后的**<font style="color:#ECAA04;">独立线程</font>**，一般可以用来实现**<font style="color:#ECAA04;">缓存功能</font>**。使用Service Worker的话，传输协议必须为**HTTPS**。因为 Service Worker中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。



Service Worker实现缓存功能一般分为三个步骤：

+ 首先需要先**<font style="color:#ECAA04;">注册 Service Worker</font>**，
+ 然后**<font style="color:#ECAA04;">监听到 </font>**`**<font style="color:#ECAA04;">install</font>**`**<font style="color:#ECAA04;"> 事件以后就可以缓存需要的文件</font>**，
+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

以下是这个步骤的实现：

```javascript
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register('sw.js')
    .then(function(registration) {
      console.log('service worker 注册成功')
    })
    .catch(function(err) {
      console.log('servcie worker 注册失败')
    })
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener('install', e => {
  e.waitUntil(
    caches.open('my-cache').then(function(cache) {
      return cache.addAll(['./index.html', './index.js'])
    })
  )
})
// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response
      }
      console.log('fetch source')
    })
  )
})
```

打开页面，可以在开发者工具中的 `Application` 看到 Service Worker 已经启动了：

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615478097248-5e3c9a93-5683-41de-8787-e87705d31fe1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_50%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

在 Cache 中也可以发现所需的文件已被缓存：

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615477994804-e7eaa2c7-91bf-406d-b024-5add76d37d5e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

# 浏览器缓存
## 对浏览器缓存机制的理解
**<font style="color:#262626;">浏览器缓存的全过程：</font>**

+ 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
+ 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回200时的时间差，如果没有超过**<font style="color:#ECAA04;">cache-control设置的max-age，则没有过期，并命中强缓存，直接从本地读取资源</font>**。如果浏览器不支持HTTP1.1，则使用**<font style="color:#ECAA04;">expires头判断是否过期</font>**；
+ 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送**<font style="color:#ECAA04;">带有If-None-Match和If-Modified-Since的请求</font>**；
+ 服务器收到请求后，优先**<font style="color:#ECAA04;">根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改</font>**，命中协商缓存，返回304；**<font style="color:#ECAA04;">如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回 200</font>**；
+ 如果服务器收到的请求没有Etag值，则**<font style="color:#ECAA04;">将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200</font>**；

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1618399660902-60a33dae-cedc-4bd0-9a5b-160c5da3f516.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

## 强缓存和协商缓存的区别
#### （1）强缓存
使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。



强缓存策略可以通过两种方式来设置，分别是**<font style="color:#ECAA04;">http头信息中的Expires属性和Cache-Control属性</font>**。



（1）服务器通过在**<font style="color:#ECAA04;">响应头中添加 Expires 属性，来指定资源的过期时间</font>**。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

（2）Expires是http1.0中的方式，因为它的一些缺点，在HTTP 1.1 中提出了一个新的头部属性就是Cache-Control属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，



`Cache-Control`可设置的字段：

+ `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
+ `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
+ `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
+ `no-store`：**<font style="color:#ECAA04;">设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源</font>**；
+ `max-age=`：**<font style="color:#ECAA04;">设置缓存的最大有效期，单位为秒</font>**；
+ `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
+ `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。



一般来说只需要设置其中一种方式就可以实现强缓存策略，**<font style="color:#ECAA04;">当两种方式一起使用时，Cache-Control 的优先级要高于 Expires</font>**。



**no-cache和no-store很容易混淆：**

+ **<font style="color:#ECAA04;">no-cache是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</font>**
+ no-store是指不使用任何缓存，每次请求都直接从服务器获取资源。

#### （2）协商缓存
如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。



上面已经说到了，命中**<font style="color:#ECAA04;">协商缓存的条件有两个</font>**：

+ `**<font style="color:#ECAA04;">max-age=xxx</font>**`**<font style="color:#ECAA04;"> 过期了</font>**
+ **<font style="color:#ECAA04;">值为</font>**`**<font style="color:#ECAA04;">no-store</font>**`



使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个304状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。



协商缓存也可以通过两种方式来设置，分别**<font style="color:#ECAA04;">是http头信息中的 Etag 和 Last-Modified 属性</font>**。

（1）服务器通过在**<font style="color:#ECAA04;">响应头中添加Last-Modified属性来指出资源最后一次修改的时间</font>**，当浏览器下一次发起请求时，会在**<font style="color:#ECAA04;">请求头中添加一个If-Modified-Since的属性，属性值为上一次资源返回时的Last-Modified的值</font>**。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，**<font style="color:#ECAA04;">就是Last-Modified标注的最后修改时间只能精确到秒级</font>**，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那**<font style="color:#ECAA04;">就是Etag属性</font>**。服务器在返回资源的时候，在**<font style="color:#ECAA04;">头信息中添加了Etag属性，这个属性是资源生成的唯一标识符</font>**，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在**<font style="color:#ECAA04;">请求头中添加一个If-None-Match属性</font>**，这个属性的值就是上次返回的资源的Etag的值。服务接收到请求后会**<font style="color:#ECAA04;">根据这个值来和资源当前的Etag的值来进行比较</font>**，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。



**<font style="color:#ECAA04;">当Last-Modified和Etag属性同时出现的时候，Etag的优先级更高</font>**。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的Last-Modified应该保持一致，因为每个服务器上Etag的值都不一样，因此在考虑负载平衡时，最好不要设置Etag属性。



**总结：**

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

## 为什么需要浏览器缓存
对于浏览器的缓存，主要针对的是**<font style="color:#ECAA04;">前端的静态资源</font>**，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。



所谓的**<font style="color:#ECAA04;">浏览器缓存</font>**指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。



使用浏览器缓存，有以下优点：

+ **<font style="color:#ECAA04;">减少了服务器的负担，提高了网站的性能</font>**
+ **<font style="color:#ECAA04;">加快了客户端网页的加载速度</font>**
+ **<font style="color:#ECAA04;">减少了多余网络数据传输</font>**

# 浏览器渲染原理

todo
